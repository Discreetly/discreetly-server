/* eslint-disable @typescript-eslint/prefer-function-type */
/* eslint-disable @typescript-eslint/consistent-type-definitions */

import { ZqField } from 'ffjavascript';
import { EdwardsPoint, WeierstrassPoint } from './babyJubjub';
import { SNARKProof } from '../../types';

export interface JubmojiRequestI {
  R: string;
  msgHash: string;
  zkp: SNARKProof;
}

export type BabyJubJub = {
  ec: any;
  Fb: ZqField;
  Fs: ZqField;
  cofactor: number;
  scalarFieldBitLength: number;
};

export type Signature = {
  r: bigint;
  s: bigint;
};

// Contents of a proof for demonstrating a valid BabyJubjub ECDSA
// signature without revealing the signature's s value
// Based on the Efficient ECDSA formulation: https://personaelabs.org/posts/efficient-ecdsa-1/
export interface MembershipProof {
  R: EdwardsPoint;
  msgHash: bigint;
  zkp: ZKP;
}

export interface PublicInputs {
  R: EdwardsPoint;
  T: EdwardsPoint;
  U: EdwardsPoint;
}

// Arguments needed to compute a merkle proof
export interface MerkleProofArgs {
  pubKeys: WeierstrassPoint[];
  index: number;
  hashFn?: any;
}

// Arguments needed to batch compute merkle proofs
export interface BatchMerkleProofArgs {
  pubKeys: WeierstrassPoint[];
  indices: number[];
  hashFn?: any;
}

// Arguments needed to compute a merkle root
export interface MerkleRootArgs {
  pubKeys: WeierstrassPoint[];
  hashFn?: any;
}

// Arguments needed to generate a membership proof
export interface ProveArgs {
  sig: Signature;
  msgHash: bigint;
  publicInputs?: PublicInputs;
  pubKey?: WeierstrassPoint;
  merkleProof?: MerkleProof;
  merkleProofArgs?: MerkleProofArgs;
  sigNullifierRandomness: bigint;
  pubKeyNullifierRandomness: bigint;
  pathToCircuits?: string;
  enableTiming?: boolean;
}

// Arguments needed to batch generate membership proofs
export interface BatchProveArgs {
  sigs: Signature[];
  msgHashes: bigint[];
  publicInputs?: PublicInputs[];
  pubKeys?: WeierstrassPoint[];
  merkleProofs?: MerkleProof[];
  merkleProofArgs?: BatchMerkleProofArgs;
  sigNullifierRandomness: bigint;
  pubKeyNullifierRandomness: bigint;
  pathToCircuits?: string;
  enableTiming?: boolean;
}

// Arguments needed to verify a membership proof
export interface VerifyArgs {
  proof: MembershipProof;
  merkleRoot?: bigint;
  merkleRootArgs?: MerkleRootArgs;
  sigNullifierRandomness: bigint;
  usedSigNullifiers?: bigint[];
  pathToCircuits?: string;
  enableTiming?: boolean;
}

// Arguments needed to batch verify membership proofs
export interface BatchVerifyArgs {
  proofs: MembershipProof[];
  merkleRoot?: bigint;
  merkleRootArgs?: MerkleRootArgs;
  sigNullifierRandomness: bigint;
  usedSigNullifiers?: bigint[];
  pathToCircuits?: string;
  enableTiming?: boolean;
}

export type VerificationResult = {
  verified: boolean;
  consumedSigNullifiers?: bigint[];
};

// Zero knowledge proof generated by snarkjs
export type ZKP = { proof: any; publicSignals: string[] };

// Inputs to the membership proof circuit
// Similar to inputs for Spartan-ecdsa membership circuit:
// https://github.com/personaelabs/spartan-ecdsa/blob/main/packages/circuits/eff_ecdsa_membership/pubkey_membership.circom
// Includes nullifierRandomness for generating unique nullifiers
export type ZKPInputs = {
  s: bigint;
  root: bigint;
  Tx: bigint;
  Ty: bigint;
  Ux: bigint;
  Uy: bigint;
  pathIndices: number[];
  siblings: bigint[];
  sigNullifierRandomness: bigint;
  pubKeyNullifierRandomness: bigint;
};

// Typed public signals for the membership proof circuit
export type ZKPPublicSignals = {
  merkleRoot: bigint;
  T: EdwardsPoint;
  U: EdwardsPoint;
  sigNullifier: bigint;
  sigNullifierRandomness: bigint;
  pubKeyNullifier: bigint;
  pubKeyNullifierRandomnessHash: bigint;
};

export interface MerkleProof {
  root: bigint;
  pathIndices: number[];
  siblings: bigint[];
}

export type Jubmoji = {
  pubKeyIndex: number; // Index of the card's public key within the list of public keys
  sig: string; // DER-encoded signature
  // msgNonce and msgRand are the counter and randomness used to generate signatures
  // See: https://github.com/arx-research/libhalo/blob/master/docs/halo-command-set.md#command-sign_random
  msgNonce: number;
  msgRand: string;
  // R, T, U are serialized points on the BabyJubjub curve represented in Edwards form.
  // They are based on the Efficient ECDSA formulation: https://personaelabs.org/posts/efficient-ecdsa-1/
  R: string;
  T: string;
  U: string;
};

export type NfcCardRawSignature = {
  r: string;
  s: string;
  v: 27 | 28;
};

// Result of signing a message with an Arx card
export type NfcCardSignMessageResult = {
  digest: string;
  rawSig: NfcCardRawSignature;
  pubKey: string;
};

// Defines a class used to create and verify proofs
export interface ProofClass<A, P> {
  prove(proofArgs: A): Promise<P>;

  verify(proof: P): Promise<VerificationResult>;
}

// Defines a constructor for a proof class
// C: Arguments needed to construct the proof class. Should be JSON.stringify-able
// A: Arguments needed to prove the proof
// P: The proof. Should be JSON.stringify-able
export interface ProofClassConstructor<C, A, P> {
  new (classArgs: C): ProofClass<A, P>;
}

// Creates an instance of a proof class
export function createProofInstance<C, A, P>(
  constructor: ProofClassConstructor<C, A, P>,
  args: C
): ProofClass<A, P> {
  return new constructor(args);
}

export interface JubmojiInCollectionClassArgs {
  collectionPubKeys: string[];
  sigNullifierRandomness: string;
  pathToCircuits?: string;
}

export interface JubmojiInCollectionProofArgs {
  jubmoji: Jubmoji;
}

export interface JubmojiInCollectionProof {
  serializedMembershipProof: string;
  usedSigNullifiers?: string[];
}

export interface JubmojiInCollectionWithNonceClassArgs {
  collectionPubKeys: string[];
  sigNullifierRandomness: string;
  pathToCircuits?: string;
}

export interface JubmojiInCollectionWithNonceProofArgs {
  jubmoji: Jubmoji;
}

export interface JubmojiInCollectionWithNonceProof {
  serializedMembershipProof: string;
  msgNonce: number;
  msgRand: string;
  usedSigNullifiers?: string[];
}

export interface NUniqueJubmojiInCollectionClassArgs {
  collectionPubKeys: string[];
  sigNullifierRandomness: string;
  N: number;
  pathToCircuits?: string;
}

export interface NUniqueJubmojiInCollectionProofArgs {
  jubmojis: Jubmoji[];
}

export interface NUniqueJubmojiInCollectionProof {
  serializedMembershipProofs: string[];
  usedSigNullifiers?: string[];
}

export interface PublicMessageSignatureClassArgs {
  randStr?: string;
}

export interface PublicMessageSignatureProofArgs {
  message: string;
  rawSig: NfcCardRawSignature;
  pubKeyIndex: number;
}

export interface PublicMessageSignatureProof {
  message: string;
  rawSig: NfcCardRawSignature;
  pubKeyIndex: number;
}

export interface TeamLeaderboardClassArgs {
  teamPubKeys: string[];
  collectionPubKeys: string[];
  sigNullifierRandomness: string;
  pathToCircuits?: string;
}

export interface TeamLeaderboardProofArgs {
  teamJubmoji: Jubmoji;
  collectionJubmojis: Jubmoji[];
}

export interface TeamLeaderboardProof {
  teamPubKeyIndex: number;
  serializedTeamMembershipProof: string;
  serializedCollectionMembershipProofs: string[];
}
